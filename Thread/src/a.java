现在，Counter2 变成了一个相当直接的程序，它的唯一任务就是设置并管理用户界面。但假若用户现在按下
        Start 按钮，却不会真正调用一个方法。
        此时不是创建类的一个线程，而是创建SeparateSubTask，然后继续
        Counter2 事件循环。注意此时会保存 SeparateSubTask 的句柄，以便我们按下onOff 按钮的时候，能正常地
        切换位于SeparateSubTask 内部的runFlag（运行标志）。随后那个线程便可启动（当它看到标志的时
        候），然后将自己中止（亦可将SeparateSubTask 设为一个内部类来达到这一目的）。
        SeparateSubTask类是对 Thread 的一个简单扩展，它带有一个构建器（其中保存了 Counter2 句柄，然后通
        过调用start()来运行线程）以及一个 run()——本质上包含了Counter1.java 的 go()内的代码。由于
        SeparateSubTask知道自己容纳了指向一个 Counter2 的句柄，所以能够在需要的时候介入，并访问 Counter2
        的TestField（文本字段）。
        按下onOff 按钮，几乎立即能得到正确的响应。当然，这个响应其实并不是“立即”发生的，它毕竟和那种
        由“中断”驱动的系统不同。只有线程拥有CPU的执行时间，并注意到标记已发生改变，计数器才会停止。
        1. 用内部类改善代码
        下面说说题外话，请大家注意一下 SeparateSubTask和 Counter2 类之间发生的结合行为。SeparateSubTask
        同Counter2“亲密”地结合到了一起——它必须持有指向自己“父”Counter2 对象的一个句柄，以便自己能
        回调和操纵它。但两个类并不是真的合并为单独一个类（尽管在下一节中，我们会讲到Java 确实提供了合并
        它们的方法），因为它们各自做的是不同的事情，而且是在不同的时间创建的。但不管怎样，它们依然紧密
        地结合到一起（更准确地说，应该叫“联合”），所以使程序代码多少显得有些笨拙。在这种情况下，一个
        内部类可以显著改善代码的“可读性”和执行效率：